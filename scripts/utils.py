from collections import OrderedDict

import numpy as np
import torch
import torch.nn as nn
from torch.utils.data import DataLoader, random_split
from torchvision import transforms as T
import torchvision.datasets as dset
from sklearn.metrics import accuracy_score


def load_pytorch_model(state_dict,resnet=False):
    new_state_dict = OrderedDict()
    for k, v in state_dict.items():
        name = k
        if name.startswith('model.'):
            name = name.replace('model.', '')  # remove `model.`
        new_state_dict[name] = v
    
    if not resnet:
        model = torch.hub.load('pytorch/vision:v0.6.0', 'inception_v3', num_classes=25, aux_logits=False,
                            transform_input=False,
                            inception_blocks=None, init_weights=None)
    else:
        model = torch.hub.load('pytorch/vision:v0.6.0', 'resnet18', pretrained=True)
        model.fc = nn.Sequential(nn.Linear(model.fc.in_features,512),
                                  nn.ReLU(),
                                  nn.Dropout(),
                                  nn.Linear(512, 5))

    model.load_state_dict(new_state_dict)
    return model


def predict(model, dataloader, n_class, device, tta=1):
    model.eval()
    model.to(device)
    preds = np.zeros([0, n_class])
    labels = []
    for data, label in dataloader:
        data = data.to(device)
        with torch.no_grad():
            y_pred = model(data).detach()
        # y_pred = F.softmax(y_pred, dim=1).cpu().numpy()
        y_pred = y_pred.cpu().numpy()
        preds = np.concatenate([preds, y_pred])
        labels = [*labels, *(label.tolist())]
    return preds, labels


def get_dataloaders(DATA_DIR):
    transform =T.Compose([
        T.Resize(256),
        T.CenterCrop(224),
        T.ToTensor(),
        T.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225]),
        ])

    dataset = dset.ImageFolder(root=DATA_DIR, transform=transform)
    train_size = int(0.8 * len(dataset))
    test_size = len(dataset) - train_size
    malware_train, malware_val = random_split(dataset, [train_size, test_size])
    train_dataset = malware_train
    val_dataset = malware_val

    train_loader = DataLoader(train_dataset, batch_size=64, pin_memory=True,
                          shuffle=True)

    
    test_loader = DataLoader(val_dataset, batch_size=64, pin_memory=True,
                          shuffle=False)

    return train_loader, test_loader


if __name__ == "__main__":

    # ngpu = 1
    # device = torch.device("cuda:0" if (torch.cuda.is_available() and ngpu > 0) else "cpu")
    # val_preds, labels = predict(best_model, val_loader, n_class=25, device=device)
    # print(f"Labels are {labels}")
    # val_acc = accuracy_score(labels, np.argmax(val_preds, axis=1))
    # print(f'val acc: {val_acc}')

    # load best model
    from pathlib import Path

    ckpt_path = list(Path('.').glob('*.ckpt'))[0]
    ckpt_path = "C:\\Users\\ahrn1e19\\final_epoch_resnet18.ckpt"
    ckpt_dict = torch.load(ckpt_path)
    #torch.save(ckpt_dict['state_dict'], "epoch_15.pth")
    best_model = load_pytorch_model(ckpt_dict['state_dict'], resnet=True)

    train_loader, val_loader = get_dataloaders("C:\\Users\\ahrn1e19\\multiclass\\image_multiclass")

    ngpu = 1
    device = torch.device("cuda:0" if (torch.cuda.is_available() and ngpu > 0) else "cpu")
    val_preds, labels = predict(best_model, val_loader, n_class=5, device=device)
    val_acc = accuracy_score(labels, np.argmax(val_preds, axis=1))
    print(f'val acc: {val_acc}')
