from collections import OrderedDict

import numpy as np
import torch
from sklearn.metrics import accuracy_score


def load_pytorch_model(state_dict, *args, **kwargs):
    new_state_dict = OrderedDict()
    for k, v in state_dict.items():
        name = k
        if name.startswith('model.'):
            name = name.replace('model.', '')  # remove `model.`
        new_state_dict[name] = v
    model = torch.hub.load('pytorch/vision:v0.6.0', 'inception_v3', num_classes=25, aux_logits=False,
                           transform_input=False,
                           inception_blocks=None, init_weights=None)
    model.load_state_dict(new_state_dict)
    return model


def predict(model, dataloader, n_class, device, tta=1):
    model.eval()
    model.to(device)
    preds = np.zeros([0, n_class])
    labels = []
    for data, label in dataloader:
        data = data.to(device)
        with torch.no_grad():
            y_pred = model(data).detach()
        # y_pred = F.softmax(y_pred, dim=1).cpu().numpy()
        y_pred = y_pred.cpu().numpy()
        preds = np.concatenate([preds, y_pred])
        labels = [*labels, *(label.tolist())]
    return preds, labels


if __name__ == "__main__":
    ngpu = 1
    device = torch.device("cuda:0" if (torch.cuda.is_available() and ngpu > 0) else "cpu")
    val_preds, labels = predict(best_model, val_loader, n_class=25, device=device)
    print(f"Labels are {labels}")
    val_acc = accuracy_score(labels, np.argmax(val_preds, axis=1))
    print(f'val acc: {val_acc}')

    # load best model
    from pathlib import Path

    ckpt_path = list(Path('.').glob('*.ckpt'))[0]
    ckpt_path = "/content/drive/My Drive/southampton/epoch=15.ckpt"
    ckpt_dict = torch.load(ckpt_path)
    torch.save(ckpt_dict['state_dict'], "epoch_15.pth")
    best_model = load_pytorch_model(ckpt_dict['state_dict'])
