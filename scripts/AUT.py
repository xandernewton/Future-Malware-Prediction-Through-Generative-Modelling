import os
import pickle
from collections import OrderedDict
from datetime import datetime
from pathlib import Path

import numpy as np
import pandas as pd
import torch
import torch.nn as nn
from PIL import Image
from torchvision.transforms import transforms
from tqdm import tqdm
from sklearn.metrics import f1_score
import os


month_results = {}

preprocess = transforms.Compose([
    transforms.Lambda(lambda image: image.convert('RGB')),
    transforms.Resize(256),
    transforms.CenterCrop(224),
    transforms.ToTensor(),
    transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225]),
])


def load_pytorch_model(state_dict):
    new_state_dict = OrderedDict()
    for k, v in state_dict.items():
        name = k
        if name.startswith('model.'):
            name = name.replace('model.', '')  # remove `model.`
        new_state_dict[name] = v

    model = torch.hub.load('pytorch/vision:v0.6.0', 'resnet18', pretrained=True)
    model.fc = nn.Sequential(nn.Linear(model.fc.in_features, 512),
                             nn.ReLU(),
                             nn.Dropout(),
                             nn.Linear(512, 2))

    model.load_state_dict(new_state_dict)
    return model


def AUT(checkpoint_path, malware_path, class_to_compare):

    truth = {"benign": 0, "malware": 1}[class_to_compare]

    device = torch.device("cuda:0" if (torch.cuda.is_available()) else "cpu")
    split_date = datetime.strptime("2015-01-12", '%Y-%m-%d').date()


    if class_to_compare == "benign":
        date_dict = pickle.load(open("..\\notebooks\\bengin_dates_4.p", "rb"))
    else:
        date_dict = pickle.load(open("..\\notebooks\\malware_dates_3.p", "rb"))

    ckpt_dict = torch.load(checkpoint_path, map_location=device)
    model = load_pytorch_model(ckpt_dict['state_dict'])
    model.eval()
    for path in tqdm(Path(malware_path).rglob('*')):
        if path.suffix == ".txt":
            continue
        elif os.path.isdir(path):
            continue
        name = path.stem
        check_date = date_dict[name]
        check_date = datetime.strptime(check_date, '%Y-%m-%d %H:%M:%S').date()

        input_image = Image.open(path)
        input_tensor = preprocess(input_image)
        input_batch = input_tensor.unsqueeze(0)  # create a mini-batch as expected by the model

        # move the input and model to GPU for speed if available
        if torch.cuda.is_available():
            input_batch = input_batch.to('cuda')
            model.to('cuda')

        with torch.no_grad():
            output = model(input_batch)
            output = (torch.argmax(output, axis=1)).item()
            if month_results.get(f"{check_date.month}-{check_date.year}"):
                month_results[f"{check_date.month}-{check_date.year}"][0].append(output)
                month_results[f"{check_date.month}-{check_date.year}"][1].append(truth)
            else:
                month_results[f"{check_date.month}-{check_date.year}"] = [[], []]
                month_results[f"{check_date.month}-{check_date.year}"][0] = [output]
                month_results[f"{check_date.month}-{check_date.year}"][1] = [truth]


def calculate_AUT():

    AUT_SCORE = 0
    f1_scores = {}
    paths = ["benign_test/", "malware_test/"]
    ckpt_path = "C:\\Users\\ahrn1e19\\resnet_began_all\\epoch=8.ckpt"
    for path in paths:
        _class = path.split("_")[0]
        AUT(ckpt_path, f"C:\\Users\\ahrn1e19\\multiclass_date_2\\multiclass_date\\{path}", _class)

    pickle.dump(f1_scores, open("month_results.p", "wb"))
    for month, results in month_results.items():
        f1_scores[month] = f1_score([x+1 for x in results[1]], [y +1 for y in results[0]])

    pickle.dump(f1_scores, open("f1_scores.p", "wb"))
    f1_scores = pickle.load(open("f1_scores.p", "rb"))

    results_df = pd.DataFrame(f1_scores.items(), columns=['Month', 'F1'])
    results_df["Month"] = results_df["Month"].astype("datetime64")
    results_df = results_df.sort_values(by=['Month'])

    for index, (_, row) in enumerate(results_df.iterrows()):
        if index == len(results_df)-1:
            continue
        current_f1 = ((row['F1'] + results_df.iloc[index + 1]['F1']) * 1/len(results_df))/2
        AUT_SCORE += current_f1

    print(f"AUT Score is {AUT_SCORE}")





if __name__ == '__main__':

    os.chdir(os.path.dirname(os.path.realpath(__file__)))

    calculate_AUT()


